{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\nvar isArray = require('isarray');\nvar typedArrayBuffer = require('typed-array-buffer');\nvar isView = ArrayBuffer.isView || function isView(obj) {\n  try {\n    typedArrayBuffer(obj);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nvar useUint8Array = typeof Uint8Array !== 'undefined';\nvar useArrayBuffer = typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined';\nvar useFromArrayBuffer = useArrayBuffer && (Buffer.prototype instanceof Uint8Array || Buffer.TYPED_ARRAY_SUPPORT);\nmodule.exports = function toBuffer(data, encoding) {\n  if (Buffer.isBuffer(data)) {\n    if (data.constructor && !('isBuffer' in data)) {\n      // probably a SlowBuffer\n      return Buffer.from(data);\n    }\n    return data;\n  }\n  if (typeof data === 'string') {\n    return Buffer.from(data, encoding);\n  }\n\n  /*\n   * Wrap any TypedArray instances and DataViews\n   * Makes sense only on engines with full TypedArray support -- let Buffer detect that\n   */\n  if (useArrayBuffer && isView(data)) {\n    // Bug in Node.js <6.3.1, which treats this as out-of-bounds\n    if (data.byteLength === 0) {\n      return Buffer.alloc(0);\n    }\n\n    // When Buffer is based on Uint8Array, we can just construct it from ArrayBuffer\n    if (useFromArrayBuffer) {\n      var res = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n      /*\n       * Recheck result size, as offset/length doesn't work on Node.js <5.10\n       * We just go to Uint8Array case if this fails\n       */\n      if (res.byteLength === data.byteLength) {\n        return res;\n      }\n    }\n\n    // Convert to Uint8Array bytes and then to Buffer\n    var uint8 = data instanceof Uint8Array ? data : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n    var result = Buffer.from(uint8);\n\n    /*\n     * Let's recheck that conversion succeeded\n     * We have .length but not .byteLength when useFromArrayBuffer is false\n     */\n    if (result.length === data.byteLength) {\n      return result;\n    }\n  }\n\n  /*\n   * Uint8Array in engines where Buffer.from might not work with ArrayBuffer, just copy over\n   * Doesn't make sense with other TypedArray instances\n   */\n  if (useUint8Array && data instanceof Uint8Array) {\n    return Buffer.from(data);\n  }\n  var isArr = isArray(data);\n  if (isArr) {\n    for (var i = 0; i < data.length; i += 1) {\n      var x = data[i];\n      if (typeof x !== 'number' || x < 0 || x > 255 || ~~x !== x // NaN and integer check\n      ) {\n        throw new RangeError('Array items must be numbers in the range 0-255.');\n      }\n    }\n  }\n\n  /*\n   * Old Buffer polyfill on an engine that doesn't have TypedArray support\n   * Also, this is from a different Buffer polyfill implementation then we have, as instanceof check failed\n   * Convert to our current Buffer implementation\n   */\n  if (isArr || Buffer.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === 'function' && data.constructor.isBuffer(data)) {\n    return Buffer.from(data);\n  }\n  throw new TypeError('The \"data\" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');\n};","map":null,"metadata":{},"sourceType":"script"}