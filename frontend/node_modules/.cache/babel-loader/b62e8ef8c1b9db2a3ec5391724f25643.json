{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\nvar toBuffer = require('./to-buffer');\nvar Transform = require('readable-stream').Transform;\nvar inherits = require('inherits');\nfunction HashBase(blockSize) {\n  Transform.call(this);\n  this._block = Buffer.allocUnsafe(blockSize);\n  this._blockSize = blockSize;\n  this._blockOffset = 0;\n  this._length = [0, 0, 0, 0];\n  this._finalized = false;\n}\ninherits(HashBase, Transform);\nHashBase.prototype._transform = function (chunk, encoding, callback) {\n  var error = null;\n  try {\n    this.update(chunk, encoding);\n  } catch (err) {\n    error = err;\n  }\n  callback(error);\n};\nHashBase.prototype._flush = function (callback) {\n  var error = null;\n  try {\n    this.push(this.digest());\n  } catch (err) {\n    error = err;\n  }\n  callback(error);\n};\nHashBase.prototype.update = function (data, encoding) {\n  if (this._finalized) {\n    throw new Error('Digest already called');\n  }\n  var dataBuffer = toBuffer(data, encoding); // asserts correct input type\n\n  // consume data\n  var block = this._block;\n  var offset = 0;\n  while (this._blockOffset + dataBuffer.length - offset >= this._blockSize) {\n    for (var i = this._blockOffset; i < this._blockSize;) {\n      block[i] = dataBuffer[offset];\n      i += 1;\n      offset += 1;\n    }\n    this._update();\n    this._blockOffset = 0;\n  }\n  while (offset < dataBuffer.length) {\n    block[this._blockOffset] = dataBuffer[offset];\n    this._blockOffset += 1;\n    offset += 1;\n  }\n\n  // update length\n  for (var j = 0, carry = dataBuffer.length * 8; carry > 0; ++j) {\n    this._length[j] += carry;\n    carry = this._length[j] / 0x0100000000 | 0;\n    if (carry > 0) {\n      this._length[j] -= 0x0100000000 * carry;\n    }\n  }\n  return this;\n};\nHashBase.prototype._update = function () {\n  throw new Error('_update is not implemented');\n};\nHashBase.prototype.digest = function (encoding) {\n  if (this._finalized) {\n    throw new Error('Digest already called');\n  }\n  this._finalized = true;\n  var digest = this._digest();\n  if (encoding !== undefined) {\n    digest = digest.toString(encoding);\n  }\n\n  // reset state\n  this._block.fill(0);\n  this._blockOffset = 0;\n  for (var i = 0; i < 4; ++i) {\n    this._length[i] = 0;\n  }\n  return digest;\n};\nHashBase.prototype._digest = function () {\n  throw new Error('_digest is not implemented');\n};\nmodule.exports = HashBase;","map":null,"metadata":{},"sourceType":"script"}