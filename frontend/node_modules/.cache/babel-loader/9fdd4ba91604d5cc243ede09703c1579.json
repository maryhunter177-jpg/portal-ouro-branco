{"ast":null,"code":"'use strict';\n\nvar md5 = require('create-hash/md5');\nvar RIPEMD160 = require('ripemd160');\nvar sha = require('sha.js');\nvar Buffer = require('safe-buffer').Buffer;\nvar checkParameters = require('./precondition');\nvar defaultEncoding = require('./default-encoding');\nvar toBuffer = require('./to-buffer');\nvar ZEROS = Buffer.alloc(128);\nvar sizes = {\n  __proto__: null,\n  md5: 16,\n  sha1: 20,\n  sha224: 28,\n  sha256: 32,\n  sha384: 48,\n  sha512: 64,\n  'sha512-256': 32,\n  ripemd160: 20,\n  rmd160: 20\n};\nvar mapping = {\n  __proto__: null,\n  'sha-1': 'sha1',\n  'sha-224': 'sha224',\n  'sha-256': 'sha256',\n  'sha-384': 'sha384',\n  'sha-512': 'sha512',\n  'ripemd-160': 'ripemd160'\n};\nfunction rmd160Func(data) {\n  return new RIPEMD160().update(data).digest();\n}\nfunction getDigest(alg) {\n  function shaFunc(data) {\n    return sha(alg).update(data).digest();\n  }\n  if (alg === 'rmd160' || alg === 'ripemd160') {\n    return rmd160Func;\n  }\n  if (alg === 'md5') {\n    return md5;\n  }\n  return shaFunc;\n}\nfunction Hmac(alg, key, saltLen) {\n  var hash = getDigest(alg);\n  var blocksize = alg === 'sha512' || alg === 'sha384' ? 128 : 64;\n  if (key.length > blocksize) {\n    key = hash(key);\n  } else if (key.length < blocksize) {\n    key = Buffer.concat([key, ZEROS], blocksize);\n  }\n  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg]);\n  var opad = Buffer.allocUnsafe(blocksize + sizes[alg]);\n  for (var i = 0; i < blocksize; i++) {\n    ipad[i] = key[i] ^ 0x36;\n    opad[i] = key[i] ^ 0x5C;\n  }\n  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4);\n  ipad.copy(ipad1, 0, 0, blocksize);\n  this.ipad1 = ipad1;\n  this.ipad2 = ipad;\n  this.opad = opad;\n  this.alg = alg;\n  this.blocksize = blocksize;\n  this.hash = hash;\n  this.size = sizes[alg];\n}\nHmac.prototype.run = function (data, ipad) {\n  data.copy(ipad, this.blocksize);\n  var h = this.hash(ipad);\n  h.copy(this.opad, this.blocksize);\n  return this.hash(this.opad);\n};\nfunction pbkdf2(password, salt, iterations, keylen, digest) {\n  checkParameters(iterations, keylen);\n  password = toBuffer(password, defaultEncoding, 'Password');\n  salt = toBuffer(salt, defaultEncoding, 'Salt');\n  var lowerDigest = (digest || 'sha1').toLowerCase();\n  var mappedDigest = mapping[lowerDigest] || lowerDigest;\n  var size = sizes[mappedDigest];\n  if (typeof size !== 'number' || !size) {\n    throw new TypeError('Digest algorithm not supported: ' + digest);\n  }\n  var hmac = new Hmac(mappedDigest, password, salt.length);\n  var DK = Buffer.allocUnsafe(keylen);\n  var block1 = Buffer.allocUnsafe(salt.length + 4);\n  salt.copy(block1, 0, 0, salt.length);\n  var destPos = 0;\n  var hLen = size;\n  var l = Math.ceil(keylen / hLen);\n  for (var i = 1; i <= l; i++) {\n    block1.writeUInt32BE(i, salt.length);\n    var T = hmac.run(block1, hmac.ipad1);\n    var U = T;\n    for (var j = 1; j < iterations; j++) {\n      U = hmac.run(U, hmac.ipad2);\n      for (var k = 0; k < hLen; k++) {\n        T[k] ^= U[k];\n      }\n    }\n    T.copy(DK, destPos);\n    destPos += hLen;\n  }\n  return DK;\n}\nmodule.exports = pbkdf2;","map":null,"metadata":{},"sourceType":"script"}